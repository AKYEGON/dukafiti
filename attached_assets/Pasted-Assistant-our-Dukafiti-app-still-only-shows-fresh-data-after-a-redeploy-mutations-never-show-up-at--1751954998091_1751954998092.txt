Assistant, our Dukafiti app still only shows fresh data after a redeploy—mutations never show up at runtime. We need to strip out every vestige of build‑time or cached data and ensure **100% runtime fetch + immediate updates** everywhere. Please perform a comprehensive, atomic refactor:

---

## 1. Globally Remove Build‑Time Data

- **Delete** any imports of JSON or hard‑coded arrays (`import products from ...`).  
- **Remove** any SSG/SSR code (`getStaticProps`, `getServerSideProps`, or Vite SSR data calls).

## 2. Runtime Data Hooks

For each of these pages/components:
- **Inventory.jsx**
- **Customers.jsx**
- **Sales.jsx**
- **Reports.jsx**
- **NotificationsDropdown.jsx**

Do the following:

1. **State & Fetch Function**  
   ```js
   const [items, setItems] = useState([]);
   const user = supabase.auth.getUser()?.data.user;

   async function fetchItems() {
     const { data, error } = await supabase
       .from('<TABLE>')                // products, customers, sales, etc.
       .select('*')
       .eq('store_id', user.id)
       .order('created_at', { ascending: false });
     if (error) console.error('Fetch error:', error);
     else setItems(data);
   }
useEffect

js
Copy
Edit
useEffect(() => {
  if (!user) return;
  fetchItems();
}, [user]);
Render

jsx
Copy
Edit
{items.length === 0
  ? <EmptyState message="No records" />
  : items.map(item => <ItemCard key={item.id} item={item} />)
}
3. Mutation Handlers + Refetch
In every “add”, “edit”, or “delete” function:

js
Copy
Edit
async function handleAdd(payload) {
  const old = items;
  setItems([resultItem, ...old]);  // optimistic
  const { error } = await supabase
    .from('<TABLE>')
    .insert([{ ...payload, store_id: user.id }]);
  if (error) {
    console.error('Insert error:', error);
    setItems(old);                // rollback
    return toast.error(error.message);
  }
  await fetchItems();             // immediate refetch
  toast.success('Added successfully');
}
Repeat for update/delete mutations, always calling await fetchItems() after.

4. Real‑Time Subscriptions
Also in each hook/component:

js
Copy
Edit
useEffect(() => {
  if (!user) return;
  fetchItems();

  const channel = supabase
    .from(`<TABLE>:store_id=eq.${user.id}`)
    .on('*', payload => {
      if (payload.eventType === 'INSERT') setItems(prev => [payload.new, ...prev]);
      if (payload.eventType === 'UPDATE') setItems(prev => prev.map(i => i.id === payload.new.id ? payload.new : i));
      if (payload.eventType === 'DELETE') setItems(prev => prev.filter(i => i.id !== payload.old.id));
    })
    .subscribe();

  return () => supabase.removeChannel(channel);
}, [user]);
5. Clear Any Caching
Service Worker (sw.js): ensure only static assets are cached. API routes must use network-first.

Fetch Options: if you use fetch anywhere, add { cache: 'no-store' }.

6. Manual Refresh Button
Add a “🔄 Refresh” button to page headers that calls fetchItems() to let users force‑reload data.

QA Checklist
 Mutations (create/update/delete) are visible immediately in the UI without any redeploy.

 Real‑time updates propagate across multiple tabs.

 No SSG/JSON imports remain—data is always fetched in the browser.

 Supabase errors are logged and surfaced via toast.

 No stale service‑worker or cache interference.

Please apply this full runtime data overhaul so Dukafiti reflects all CRUD changes immediately—no rebuilds required. ```








Ask ChatGPT
