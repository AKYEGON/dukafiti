Assistant, our Dukafiti app still only shows fresh data after a redeployâ€”mutations never show up at runtime. We need to strip out every vestige of buildâ€‘time or cached data and ensure **100% runtime fetch + immediate updates** everywhere. Please perform a comprehensive, atomic refactor:

---

## 1. Globally Remove Buildâ€‘Time Data

- **Delete** any imports of JSON or hardâ€‘coded arrays (`import products from ...`).  
- **Remove** any SSG/SSR code (`getStaticProps`, `getServerSideProps`, or Vite SSR data calls).

## 2. Runtime Data Hooks

For each of these pages/components:
- **Inventory.jsx**
- **Customers.jsx**
- **Sales.jsx**
- **Reports.jsx**
- **NotificationsDropdown.jsx**

Do the following:

1. **State & Fetch Function**  
   ```js
   const [items, setItems] = useState([]);
   const user = supabase.auth.getUser()?.data.user;

   async function fetchItems() {
     const { data, error } = await supabase
       .from('<TABLE>')                // products, customers, sales, etc.
       .select('*')
       .eq('store_id', user.id)
       .order('created_at', { ascending: false });
     if (error) console.error('Fetch error:', error);
     else setItems(data);
   }
useEffect

js
Copy
Edit
useEffect(() => {
  if (!user) return;
  fetchItems();
}, [user]);
Render

jsx
Copy
Edit
{items.length === 0
  ? <EmptyState message="No records" />
  : items.map(item => <ItemCard key={item.id} item={item} />)
}
3. Mutation Handlers + Refetch
In every â€œaddâ€, â€œeditâ€, or â€œdeleteâ€ function:

js
Copy
Edit
async function handleAdd(payload) {
  const old = items;
  setItems([resultItem, ...old]);  // optimistic
  const { error } = await supabase
    .from('<TABLE>')
    .insert([{ ...payload, store_id: user.id }]);
  if (error) {
    console.error('Insert error:', error);
    setItems(old);                // rollback
    return toast.error(error.message);
  }
  await fetchItems();             // immediate refetch
  toast.success('Added successfully');
}
Repeat for update/delete mutations, always calling await fetchItems() after.

4. Realâ€‘Time Subscriptions
Also in each hook/component:

js
Copy
Edit
useEffect(() => {
  if (!user) return;
  fetchItems();

  const channel = supabase
    .from(`<TABLE>:store_id=eq.${user.id}`)
    .on('*', payload => {
      if (payload.eventType === 'INSERT') setItems(prev => [payload.new, ...prev]);
      if (payload.eventType === 'UPDATE') setItems(prev => prev.map(i => i.id === payload.new.id ? payload.new : i));
      if (payload.eventType === 'DELETE') setItems(prev => prev.filter(i => i.id !== payload.old.id));
    })
    .subscribe();

  return () => supabase.removeChannel(channel);
}, [user]);
5. Clear Any Caching
Service Worker (sw.js): ensure only static assets are cached. API routes must use network-first.

Fetch Options: if you use fetch anywhere, add { cache: 'no-store' }.

6. Manual Refresh Button
Add a â€œğŸ”„ Refreshâ€ button to page headers that calls fetchItems() to let users forceâ€‘reload data.

QA Checklist
 Mutations (create/update/delete) are visible immediately in the UI without any redeploy.

 Realâ€‘time updates propagate across multiple tabs.

 No SSG/JSON imports remainâ€”data is always fetched in the browser.

 Supabase errors are logged and surfaced via toast.

 No stale serviceâ€‘worker or cache interference.

Please apply this full runtime data overhaul so Dukafiti reflects all CRUD changes immediatelyâ€”no rebuilds required. ```








Ask ChatGPT
