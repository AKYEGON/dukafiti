Assistant, data still isnâ€™t updating liveâ€”letâ€™s instrument and fix every step of our CRUD and fetch flow. Please refactor our Inventory and Customers pages (and their shared hooks) to add exhaustive logging and ensure runtime updates. Overwrite these components/hooks to do the following:

---

## A. Instrumented `useData` Hook

Create a generic hook `useData(table)` in `src/hooks/useData.js`:

```js
import { useState, useEffect } from 'react';
import { supabase } from '../supabaseClient';

export default function useData(table) {
  const [items, setItems] = useState([]);
  const [debug, setDebug] = useState([]);
  const user = supabase.auth.getUser()?.data.user;

  async function fetchData() {
    console.log(`[${table}] fetchData start`, { userId: user?.id });
    setDebug(prev => [...prev, `${table}: fetch start`]);
    const { data, error } = await supabase
      .from(table)
      .select('*')
      .eq('store_id', user.id)
      .order('created_at', { ascending: false });
    if (error) {
      console.error(`[${table}] fetchData error:`, error);
      setDebug(prev => [...prev, `${table}: fetch error: ${error.message}`]);
    } else {
      console.log(`[${table}] fetchData success:`, data);
      setDebug(prev => [...prev, `${table}: fetched ${data.length} items`]);
      setItems(data);
    }
  }

  useEffect(() => {
    if (!user) return;
    fetchData();

    const channel = supabase
      .from(`${table}:store_id=eq.${user.id}`)
      .on('*', payload => {
        console.log(`[${table}] realtime ${payload.eventType}:`, payload);
        setDebug(prev => [...prev, `${table}: realtime ${payload.eventType}`]);
        setItems(prev => {
          switch (payload.eventType) {
            case 'INSERT': return [payload.new, ...prev];
            case 'UPDATE': return prev.map(i => i.id === payload.new.id ? payload.new : i);
            case 'DELETE': return prev.filter(i => i.id !== payload.old.id);
            default: return prev;
          }
        });
      })
      .subscribe();
    return () => supabase.removeChannel(channel);
  }, [user]);

  return { items, fetchData, debug };
}
B. Refactor Pages to Use useData
Inventory.jsx
jsx
Copy
Edit
import useData from '../hooks/useData';

export default function Inventory() {
  const { items: products, fetchData: refresh, debug } = useData('products');

  // Mutation example
  async function handleRestock(productId, qty, buyPrice) {
    console.log('restock start', { productId, qty, buyPrice });
    await supabase
      .from('products')
      .update({
        quantity: supabase.raw('quantity + ?', [qty]),
        cost_price: buyPrice
      })
      .eq('id', productId)
      .eq('store_id', supabase.auth.getUser().data.user.id);
    console.log('restock complete, refetching');
    await refresh();
  }

  return (
    <div>
      <button onClick={refresh}>ðŸ”„ Refresh</button>
      <pre>{debug.join('\n')}</pre>
      {products.map(p => /* display product cards */)}
      {/* restock modal would call handleRestock */}
    </div>
  );
}
Customers.jsx
Similar, swapping 'customers' and relevant mutation code.

C. Testing & Verification
Open console: you should see logs for fetch start, success, realtime events.

Perform mutations: ensure mutation logs appear and refresh() runs.

No silent failures: any Supabase errors must log in console.

Realtime: if you mutate in another tab, log the realtime payload and UI must update.

This instrumentation will expose exactly where data is failing to load or update. Once logs confirm the flow, we can remove the debug prints and confirm live updates without rebuilds.```








Ask ChatGPT
