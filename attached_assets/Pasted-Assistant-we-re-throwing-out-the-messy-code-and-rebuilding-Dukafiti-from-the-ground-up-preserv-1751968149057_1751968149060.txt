Assistant, we’re throwing out the messy code and rebuilding Dukafiti **from the ground up**, preserving only our high‑level structure (React + Supabase + Vercel) but rewriting every piece to be clean, atomic, and fully functioning—including RLS, auth, CRUD, offline queue, real‑time updates, and multi‑tenant isolation. Follow this plan exactly:

---

## 1. Project Structure

src/
├─ assets/ # logos, banners, icons
├─ components/ # reusable UI components (Button, Card, Modal…)
├─ contexts/
│ └─ AuthContext.tsx
├─ hooks/
│ ├─ useLiveData.ts # generic data loader + subscription
│ ├─ useMutation.ts # generic mutation + optimistic + invalidation
│ └─ useOfflineQueue.ts
├─ lib/
│ └─ supabase.ts # supabase client init
├─ pages/
│ ├─ Dashboard.tsx
│ ├─ Inventory.tsx
│ ├─ Customers.tsx
│ ├─ Sales.tsx
│ ├─ Reports.tsx
│ └─ Settings.tsx
├─ service-worker.js # PWA SW caching static assets only
├─ App.tsx
└─ main.tsx

pgsql
Copy
Edit

Delete **all** other files (old utils, data JSON, experiments).

---

## 2. Multi‑Tenant & RLS

In Supabase SQL editor, for each table (`products`, `customers`, `sales`, `notifications`, `settings`, etc.):

```sql
ALTER TABLE <table> ENABLE ROW LEVEL SECURITY;
ALTER TABLE <table> ADD COLUMN IF NOT EXISTS store_id uuid NOT NULL;

-- Admin bypass policy (replace <ADMIN_UID>)
CREATE POLICY "admin full access" ON <table>
  FOR ALL USING (auth.uid() = '<ADMIN_UID>');

-- Tenant isolation
CREATE POLICY "users can CRUD own rows" ON <table>
  FOR ALL
  USING (store_id = auth.uid())
  WITH CHECK (store_id = auth.uid());
3. Auth Context
contexts/AuthContext.tsx:

Wraps supabase.auth.onAuthStateChange, provides { user, session }.

4. Supabase Client
lib/supabase.ts:

ts
Copy
Edit
import { createClient } from '@supabase/supabase-js';
export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON_KEY!
);
5. Shared Data Hook
hooks/useLiveData.ts (generic):

ts
Copy
Edit
import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import { useAuth } from '../contexts/AuthContext';

export default function useLiveData<T>(table: string) {
  const { user } = useAuth();
  const [items, setItems] = useState<T[]>([]);

  useEffect(() => {
    if (!user) return;
    let mounted = true;

    // Initial load
    supabase
      .from<T>(table)
      .select('*')
      .eq('store_id', user.id)
      .order('created_at', { ascending: false })
      .then(({ data, error }) => {
        if (error) console.error(table, 'fetch:', error);
        else if (mounted) setItems(data);
      });

    // Realtime subscription
    const channel = supabase
      .from<T>(`${table}:store_id=eq.${user.id}`)
      .on('*', payload => {
        setItems(prev => {
          switch (payload.eventType) {
            case 'INSERT': return [payload.new, ...prev];
            case 'UPDATE': return prev.map(i => i.id === payload.new.id ? payload.new : i);
            case 'DELETE': return prev.filter(i => i.id !== payload.old.id);
          }
          return prev;
        });
      })
      .subscribe();

    return () => {
      mounted = false;
      supabase.removeChannel(channel);
    };
  }, [user, table]);

  return items;
}
6. Generic Mutation Hook
hooks/useMutation.ts:

ts
Copy
Edit
import { supabase } from '../lib/supabase';
import { useAuth } from '../contexts/AuthContext';

export default function useMutation<T>(
  table: string,
  type: 'insert' | 'update' | 'delete'
) {
  const { user } = useAuth();

  async function mutate(payload: Partial<T> & { id?: string }) {
    if (!user) throw new Error('Not authenticated');
    let query;
    if (type === 'insert') {
      query = supabase
        .from<T>(table)
        .insert([{ ...payload, store_id: user.id }]);
    } else if (type === 'update' && payload.id) {
      const { id, ...rest } = payload;
      query = supabase
        .from<T>(table)
        .update(rest)
        .eq('id', id)
        .eq('store_id', user.id);
    } else if (type === 'delete' && payload.id) {
      query = supabase
        .from<T>(table)
        .delete()
        .eq('id', payload.id)
        .eq('store_id', user.id);
    } else throw new Error('Invalid mutation');

    const { error } = await query;
    if (error) throw error;
  }

  return mutate;
}
7. Offline Queue Hook
hooks/useOfflineQueue.ts:

Implement enqueue, syncQueue, and useOnlineListener as previously specified, but delete old code.

8. Component Refactor
For Inventory.tsx and Customers.tsx (and similarly for Sales):

tsx
Copy
Edit
import useLiveData from '../hooks/useLiveData';
import useMutation from '../hooks/useMutation';

export default function Inventory() {
  const products = useLiveData<Product>('products');
  const addProduct = useMutation<Product>('products', 'insert');
  const updateProduct = useMutation<Product>('products', 'update');
  const deleteProduct = useMutation<Product>('products', 'delete');

  // render grid of ProductCard, passing add/edit/delete handlers
  // clicking “Add”, “Edit”, “Delete” calls the appropriate mutate()
  // no manual fetch needed—liveData auto‑updates

  return <YourInventoryUI products={products} /* handlers */ />;
}
9. UI & Components Cleanup
Consolidate components/Card, Modal, Button, etc.

Ensure all old CSS, unused files, console.logs are removed.

10. Final QA
Login as two different users → each sees only their own data.

Dashboard, Inventory, Customers, Sales, Reports, Notifications all load live data.

Add/Edit/Delete on any page updates instantly (via realtime) with no rebuild.

Offline operations queue and sync on reconnect.

Service Worker caches only static assets.

Please perform this atomic, ground‑up refactor—deleting everything unnecessary and rebuilding as outlined—so Dukafiti finally works correctly for all CRUD, realtime, offline, and multi‑tenant scenarios.```








Ask ChatGPT
